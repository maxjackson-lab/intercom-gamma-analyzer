# Cursor Rules for Intercom Analysis Tool

## Project Context
This is a multi-agent ETL system that analyzes Intercom conversations using specialized AI agents. The system uses:
- Python async/await patterns
- Pydantic models for validation
- Custom BaseAgent pattern for all agents
- Intercom SDK for data fetching
- Gamma API for presentation generation

## Code Style & Patterns

### Agent Development
- All agents inherit from `BaseAgent` and implement `execute(context: AgentContext) -> AgentResult`
- Use `AgentContext` to pass data between agents
- Return `AgentResult` with confidence scores, limitations, and sources
- Always validate input/output using `validate_input()` and `validate_output()`
- Use confidence levels: HIGH (>0.8), MEDIUM (0.6-0.8), LOW (<0.6)

### Error Handling
- Use `exponential_backoff_retry()` from `src.utils.backoff` for transient failures
- Return `AgentResult` with `success=False` instead of raising exceptions when possible
- Log errors with context: `self.logger.error("error_key", agent=agent.name, error=str(e))`
- Use circuit breaker pattern for repeated failures (see `src/utils/circuit_breaker.py`)

### Async Patterns
- Always use `async def` for agent methods
- Use `asyncio.Semaphore` for concurrency control
- Use `asyncio.wait_for()` with timeouts for agent execution
- Never block the event loop - use `await` for all I/O operations

### Data Validation
- Use Pydantic models for all data structures
- Validate conversation data before processing
- Check for required fields before accessing nested data
- Use `extract_conversation_text()` utility for text extraction

### Hallucination Prevention
- Always use "According to the analysis" or "Based on the data" for claims
- Never invent URLs, conversation links, or external references
- State limitations when data is incomplete
- Use confidence scores to qualify uncertain insights
- Implement reflection pattern for low-confidence results (<0.7)

## File Organization

### Agent Files (`src/agents/`)
- One agent per file: `{agent_name}_agent.py`
- Import from `src.agents.base_agent` for BaseAgent, AgentContext, AgentResult
- Keep agent-specific logic in the agent class
- Use `src.agents.tools` for reusable tools

### Service Files (`src/services/`)
- API clients: `{service}_client.py` (e.g., `intercom_sdk_service.py`, `gamma_client.py`)
- Business logic: `{domain}_service.py` (e.g., `chunked_fetcher.py`)
- Use async/await for all service methods
- Implement retry logic with exponential backoff

### Utilities (`src/utils/`)
- Conversation processing: `conversation_utils.py`
- Time handling: `time_utils.py`, `timezone_utils.py`
- Retry logic: `retry.py`, `backoff.py`
- Error recovery: `circuit_breaker.py`

## API Integration Patterns

### Intercom API
- Use `IntercomSDKService` for all Intercom API calls
- Handle rate limits automatically (SDK does this)
- Use `ChunkedFetcher` for large date ranges (>3 days)
- Always deduplicate conversations by ID

### Gamma API
- Use `GammaClient` for presentation generation
- Theme names automatically resolve to themeIds (v1.0 API)
- Use `GammaGenerator` wrapper for higher-level operations
- Handle polling with exponential backoff

## Testing Patterns
- Test agents with `AgentContext` fixtures
- Mock external APIs (Intercom, Gamma)
- Test error recovery and retry logic
- Test confidence scoring and reflection

## Common Mistakes to Avoid

### ❌ DON'T:
- Raise exceptions in agent `execute()` methods (return AgentResult with success=False)
- Block the event loop with synchronous I/O
- Invent conversation links or URLs
- Access nested dict keys without checking existence
- Use hardcoded timeouts (use configurable timeouts)
- Skip input validation

### ✅ DO:
- Return AgentResult for all agent outputs
- Use async/await for all I/O
- Ground all claims in data ("According to...")
- Use safe dict access: `conv.get('field', default)`
- Use configurable timeouts from settings
- Validate inputs before processing

## Prompting Guidelines for Cursor

### When asking for agent code:
- Specify the agent's purpose and input/output format
- Include example AgentContext and AgentResult structures
- Mention confidence scoring requirements
- Specify error handling approach

### When asking for fixes:
- Include the full error traceback
- Specify which agent/service is failing
- Mention if it's a transient or permanent error
- Include relevant context (date range, conversation count, etc.)

### When asking for new features:
- Describe the agent's role in the workflow
- Specify dependencies on other agents
- Mention if it needs tools or external APIs
- Include expected confidence levels

## Performance Considerations
- Use semaphores to limit concurrent agent execution
- Batch API calls when possible
- Cache theme IDs and other static data
- Use checkpointing for long-running analyses
- Implement circuit breakers for failing services

## Security & Best Practices
- Never log API keys or sensitive tokens
- Use environment variables for configuration
- Validate all user inputs
- Sanitize conversation text before logging
- Use structured logging with context

## CLI ↔ Web UI ↔ Railway Alignment (CRITICAL)

### The 3-Layer Contract
Every CLI command has 3 implementations that MUST stay aligned:
1. **CLI** (`src/main.py`) - Source of truth, actual implementation
2. **Railway** (`deploy/railway_web.py`) - Validation layer in CANONICAL_COMMAND_MAPPINGS
3. **Frontend** (`static/app.js`) - UI that sends commands

### MANDATORY: When Adding/Changing ANY Flag

**Always update ALL 3 layers in this order:**

1. **CLI First** (`src/main.py`):
```python
@cli.command(name='your-command')
@click.option('--your-flag', type=click.Choice(['val1', 'val2']), default='val1')
def your_command(..., your_flag: str):  # ← MUST be in signature!
    # Actually USE the flag (don't just accept it)
```

2. **Railway Second** (`deploy/railway_web.py`):
```python
CANONICAL_COMMAND_MAPPINGS = {
    'your_command': {
        'allowed_flags': {
            '--your-flag': {
                'type': 'enum',  # MUST match CLI type
                'values': ['val1', 'val2'],  # MUST match CLI choices
                'default': 'val1'  # MUST match CLI default
            }
        }
    }
}
```

3. **Frontend Last** (`static/app.js`):
```javascript
if (analysisType === 'your-command') {
    const flagValue = document.getElementById('yourFlag')?.value;
    args.push('--your-flag', flagValue);
}
```

### Verification Checklist

Before committing changes to commands/flags:
- [ ] Run `python scripts/check_cli_web_alignment.py`
- [ ] Verify flag is in CLI `@click.option`
- [ ] Verify flag is in function signature
- [ ] Verify flag is in Railway `allowed_flags`
- [ ] Verify types match (enum=Choice, boolean=is_flag)
- [ ] Verify frontend sends flag conditionally (not to all commands)
- [ ] Test in web UI (no validation errors)

### Common Mistakes
- ❌ Adding flag to Railway but forgetting CLI function signature
- ❌ Frontend sending --verbose to diagnostic modes (sample-mode)
- ❌ Type mismatch: Railway says 'boolean' but CLI uses Choice
- ❌ Values mismatch: Railway says ['quick'] but CLI says ['fast']

### Reference
See `CLI_WEB_ALIGNMENT_CHECKLIST.md` for detailed guide



